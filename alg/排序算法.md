## 介绍

## 度量

衡量一个算法性能最重要的维度，无非是时间复杂度和空间复杂度。我喜欢简单易懂的解释一个概念，愿意放弃一些精确性。所以在我的理解里，时间复杂度就是算法运行时间的增长与输入规模增长的关系，以大O表示法标识。空间复杂度则是算法需要的额外内存空间。

当更加具体地，我们需要衡量一个排序算法的优劣时，还会考虑到一些别的方面。综合如下：

* 时间复杂度
* 空间复杂度
* 比较次数。即算法需要比较两个数或者对象的次数
* 交换次数。即算法需要交换两个数或者对象的次数
* 输入依赖。即算法性能，如时间复杂度等是否会依赖输入序列
* 稳定性。即对于重复元素，算法是否会交换二者的顺序

## 各大排序算法介绍

### 冒泡排序

冒泡排序的思路很简单，每次比较相邻的两个元素，把更大的交换到右边，则每次下来都能确定一个最大的数

#### java实现：

```java
public static void bubbleSort(int[] a) {
  //遍历
  for (int i = 0; i < a.length; i++) {
    //每一趟下来，都会获得一个最大的数，排在第a.length - i 个位置上
    for (int j = 1; j < a.length - i; j++) {
      //如果前面的数比较大，就交换
      if (a[j] < a[j - 1]) {
        int t = a[j - 1];
        a[j - 1] = a[j];
        a[j] = t;
      }
    }
  }
}
```

#### 动画演示

<img src="/Users/didi/workspace/study/my-note/pic/算法/冒泡.gif" style="zoom:80%;" />

#### 算法分析

* 时间复杂度。两层for循环，O(n<sup>2</sup>)

* 额外空间。不需要
* 比较次数。根据算法实现，比较次数未：n + (n-1) + (n-2) + ... +1 ≈ n<sup>2</sup>
* 交换次数。即是输入序列的逆序数。所以最优情况下，即输入序列已经排好序了，就是0次交换；最差情况下，输入序列是逆序的，则需要n<sup>2</sup>级别的交换次数
* 稳定性。稳定

### 选择排序

选择排序可以当做是冒泡的一种升级，它的思路是，每一趟找到一个最大的数，然后跟最右边的数交换。（选最小数思路一致）；每一趟下来就可以确定一个正确的位置，n趟下来数组就排好序了。

#### java实现

```java
public static void selectionSort(int[] a) {
  //遍历
  for (int i = 0; i < a.length; i++) {
    //第i趟，就确定第i个位置的数字
    int min = i;
    //找到i以后的位置上的最小的数
    for (int j = i + 1; j < a.length; j++) {
      if (a[j] < a[min]) {
        min = j;
      }
    }
    //交换位置
    int t = a[min];
    a[min] = a[i];
    a[i] = t;
  }
}
```

#### 动画演示

<img src="/Users/didi/workspace/study/my-note/pic/算法/选择排序.gif" style="zoom:80%;" />

#### 算法分析

选择排序可以看成是升级版的冒泡排序，改进的点就是交换的次数。冒泡算法在最坏情况下需要O(n<sup>2</sup>)级别的交换，而选择排序顶多需要n次交换。其他方面都是跟冒泡排序一致

### 插入排序

插入排序的原理是，对于第i趟比较，第0 - i个数是局部有序的，就是0 - i个数是已经排好序的，然后i+1个数，一次从后向前找到一个合适的位置插入。

#### java实现

```java
public static void insertionSort(int[] a) {
  for (int i = 01; i < a.length; i++) {
    for (int j = i; j > 0 && a[j] < a[j - 1]; j--) {
      int t = a[j];
      a[j] = a[j - 1];
      a[j - 1] = t;
    }

  }
}
```

#### 动画演示

<img src="/Users/didi/workspace/study/my-note/pic/算法/插入排序.gif" style="zoom:80%;" />

#### 算法分析

* 时间复杂度。两层for循环，O(n<sup>2</sup>)。

* 额外空间。不需要
* 比较次数。跟逆序数相关。如果数据已经排好序了，则比较次数为n级别，如果输入序列完全是倒序的，则需要的比较次数未O(n<sup>2</sup>)级别
* 交换次数。跟输入序列的逆序数相关。所以最优情况下，即输入序列已经排好序了，就是0次交换；最差情况下，输入序列是逆序的，则需要n<sup>2</sup>级别的交换次数
* 稳定性。稳定

插入排序也可以看做是对选择排序的升级，相较而言，选择排序需要更少的比较次数。

### 希尔排序

希尔排序是对插入排序的一种改进。为了理解希尔排序存在的意义以及它为何是插入排序的改进，我们从另一个角度考虑排序算法：逆序数。现在，我们可以把排序理解为将输入序列的逆序数降为0的过程。插入排序的每次交换，会使逆序数降低1。而希尔排序，就是希望可以在一次交换中，使逆序数的下降超过1。假设输入序列为：5，4，3，2，1。完全倒序，如果使用插入排序，我们需要1+2+3+4 = 10次交换。如果使用2，1 h序列的希尔排序：则只需4次交换（h=2时就完成了排序）

### 归并排序

