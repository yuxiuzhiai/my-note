# 概念

# 组件

## Consumer

消费者。对应接口MQConsumer

```java
public interface MQConsumer extends MQAdmin {
	//发送回执
  void sendMessageBack(final MessageExt msg, final int delayLevel, final String brokerName)
    throws RemotingException, MQBrokerException, InterruptedException, MQClientException;
	//获取具体要消费的topic的消费队列
  Set<MessageQueue> fetchSubscribeMessageQueues(final String topic) throws MQClientException;
}
```

可以看到消费者接口居然没有定义具体消费的方法，这还有王法？

具体的消费方法，定义在其两种不同的子接口里面

### MQPullConsumer

基于拉模式的消费者

```java
public interface MQPullConsumer extends MQConsumer {
  //启动consumer
  void start() throws MQClientException;
	//关闭consumer
  void shutdown();
	//注册监听器
  void registerMessageQueueListener(final String topic, final MessageQueueListener listener);
	//拉取消息
  PullResult pull(final MessageQueue mq, final String subExpression, final long offset,final int maxNums);
  //异步拉取消息
  void pull(final MessageQueue mq, final String subExpression, final long offset, final int maxNums,
            final PullCallback pullCallback)
	//更新消费位置
  void updateConsumeOffset(final MessageQueue mq, final long offset) throws MQClientException;
	//获取消费位置
  long fetchConsumeOffset(final MessageQueue mq, final boolean fromStore) throws MQClientException;

  Set<MessageQueue> fetchMessageQueuesInBalance(final String topic) throws MQClientException;

  void sendMessageBack(MessageExt msg, int delayLevel, String brokerName, String consumerGroup);
	
  //省略了很多pull()的重载方法
  
}
```

### MQPushConsumer

基于推模式的consumer接口

```java
public interface MQPushConsumer extends MQConsumer {
		//同MQPullConsumer
    void start() throws MQClientException;
    void shutdown();
    void registerMessageListener(final MessageListenerConcurrently messageListener);
    void registerMessageListener(final MessageListenerOrderly messageListener);

    //订阅主题
    void subscribe(final String topic, final String subExpression) throws MQClientException;
		//取消订阅
    void unsubscribe(final String topic);

    /**
     * Update the consumer thread pool size Dynamically
     */
    void updateCorePoolSize(int corePoolSize);
    //暂停
    void suspend();
		//恢复
    void resume();
}

```

### LitePullConsumer

其实上面提到的MQPullConsumer的唯一具体实现DefaultMQPullConsumer已经被标记为@Deprecated的。在rocketmq中，基于拉模式的消费者，已经是LitePullConsumer接口了：

```java
public interface LitePullConsumer {
		//同上
    void start() throws MQClientException;
    void shutdown();
    void subscribe(final String topic, final String subExpression) throws MQClientException;
    void subscribe(final String topic, final MessageSelector selector) throws MQClientException;
    void unsubscribe(final String topic);

    /**
     * Manually assign a list of message queues to this consumer. This interface does not allow for incremental
     * assignment and will replace the previous assignment (if there is one).
     *
     * @param messageQueues Message queues that needs to be assigned.
     */
    void assign(Collection<MessageQueue> messageQueues);

    /**
     * Fetch data for the topics or partitions specified using assign API
     *
     * @return list of message, can be null.
     */
    List<MessageExt> poll();

    /**
     * Fetch data for the topics or partitions specified using assign API
     *
     * @param timeout The amount time, in milliseconds, spent waiting in poll if data is not available. Must not be
     * negative
     * @return list of message, can be null.
     */
    List<MessageExt> poll(long timeout);

    /**
     * Overrides the fetch offsets that the consumer will use on the next poll. If this API is invoked for the same
     * message queue more than once, the latest offset will be used on the next poll(). Note that you may lose data if
     * this API is arbitrarily used in the middle of consumption.
     *
     * @param messageQueue
     * @param offset
     */
    void seek(MessageQueue messageQueue, long offset) throws MQClientException;

    /**
     * Suspend pulling from the requested message queues.
     *
     * Because of the implementation of pre-pull, fetch data in {@link #poll()} will not stop immediately until the
     * messages of the requested message queues drain.
     *
     * Note that this method does not affect message queue subscription. In particular, it does not cause a group
     * rebalance.
     *
     * @param messageQueues Message queues that needs to be paused.
     */
    void pause(Collection<MessageQueue> messageQueues);

    /**
     * Resume specified message queues which have been paused with {@link #pause(Collection)}.
     *
     * @param messageQueues Message queues that needs to be resumed.
     */
    void resume(Collection<MessageQueue> messageQueues);

    /**
     * Whether to enable auto-commit consume offset.
     *
     * @return true if enable auto-commit, false if disable auto-commit.
     */
    boolean isAutoCommit();

    /**
     * Set whether to enable auto-commit consume offset.
     *
     * @param autoCommit Whether to enable auto-commit.
     */
    void setAutoCommit(boolean autoCommit);

    /**
     * Get metadata about the message queues for a given topic.
     *
     * @param topic The topic that need to get metadata.
     * @return collection of message queues
     * @throws MQClientException if there is any client error.
     */
    Collection<MessageQueue> fetchMessageQueues(String topic) throws MQClientException;

    /**
     * Look up the offsets for the given message queue by timestamp. The returned offset for each message queue is the
     * earliest offset whose timestamp is greater than or equal to the given timestamp in the corresponding message
     * queue.
     *
     * @param messageQueue Message queues that needs to get offset by timestamp.
     * @param timestamp
     * @return offset
     * @throws MQClientException if there is any client error.
     */
    Long offsetForTimestamp(MessageQueue messageQueue, Long timestamp) throws MQClientException;

    /**
     * Manually commit consume offset.
     */
    void commitSync();

    /**
     * Get the last committed offset for the given message queue.
     *
     * @param messageQueue
     * @return offset, if offset equals -1 means no offset in broker.
     * @throws MQClientException if there is any client error.
     */
    Long committed(MessageQueue messageQueue) throws MQClientException;

    /**
     * Register a callback for sensing topic metadata changes.
     *
     * @param topic The topic that need to monitor.
     * @param topicMessageQueueChangeListener Callback when topic metadata changes, refer {@link
     * TopicMessageQueueChangeListener}
     * @throws MQClientException if there is any client error.
     */
    void registerTopicMessageQueueChangeListener(String topic,
        TopicMessageQueueChangeListener topicMessageQueueChangeListener) throws MQClientException;
}
```

## MQConsumerInner

私以为，rocketmq的消费者实现，是一种桥接模式的实现：分离抽象和实现，各自在独立的类层次结构中，分别变化。所以对于抽象：MQConsumer，其具体实现内部都聚合了一个实现：MQConsumerInner。

接口定义：

```java
public interface MQConsumerInner {
  String groupName();

  MessageModel messageModel();

  ConsumeType consumeType();

  ConsumeFromWhere consumeFromWhere();

  Set<SubscriptionData> subscriptions();

  void doRebalance();

  void persistConsumerOffset();

  void updateTopicSubscribeInfo(final String topic, final Set<MessageQueue> info);

  boolean isSubscribeTopicNeedUpdate(final String topic);

  boolean isUnitMode();

  ConsumerRunningInfo consumerRunningInfo();
}
```

从接口定义的方法也可以看出，MQConsumer的方法都是一种更高层面的抽象，比如pull();而MQConsumerInner接口定义的方法则更为具体，比如consumeFromWhere()

## OffsetStore

在rocketmq中，OffsetStore代表着消费者偏移量存储这一概念。接口定义如下：

```java
public interface OffsetStore {
	//加载
  void load() throws MQClientException;
	//更新本地的偏移量
  void updateOffset(final MessageQueue mq, final long offset, final boolean increaseOnly);
  //从本地读取偏移量
  long readOffset(final MessageQueue mq, final ReadOffsetType type);
	//持久化
  void persistAll(final Set<MessageQueue> mqs);
	//移除偏移量
  void removeOffset(MessageQueue mq);
	//克隆
  Map<MessageQueue, Long> cloneOffsetTable(String topic);
	//更新broker里的偏移量
  void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException,
  MQBrokerException, InterruptedException, MQClientException;
}
```

其有两个实现：

* LocalFileOffsetStore:对应广播模式的消费者，每个消费者自己在本地通过一个本地文件维护偏移量
* RemoteBrokerOffsetStore：对应集群模式的消费者，偏移量保存在broker

# 实现

我们先看看基于push模式的消费者实现。

## 1. push模式消费者的实现

先看消费者的启动，即DefaultMQPushConsumer.start()方法

## 启动

```java
public void start() throws MQClientException {
  setConsumerGroup(NamespaceUtil.wrapNamespace(this.getNamespace(), this.consumerGroup));
  //核心逻辑
  this.defaultMQPushConsumerImpl.start();
  if (null != traceDispatcher) {
    try {
      traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());
    } catch (MQClientException e) {
      log.warn("trace dispatcher start failed ", e);
    }
  }
}
```

### DefaultMQPushConsumerImpl的启动

方法如下：

```java
public synchronized void start() throws MQClientException {
  
  //删除了switch检查状态的代码，switch是为了确保次方法只被调用一次。
  
  this.serviceState = ServiceState.START_FAILED;
  //1.检查各个配置项是否正常
  this.checkConfig();
  //2.构建订阅主题信息
  this.copySubscription();

  if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {
    this.defaultMQPushConsumer.changeInstanceNameToPID();
  }
  //3.创建MQClientInstance
  this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);

  this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());
  this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());
  this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());
  this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);
  //
  this.pullAPIWrapper = new PullAPIWrapper(mQClientFactory,this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());
  this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);

  if (this.defaultMQPushConsumer.getOffsetStore() != null) {
    this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();
  } else {
    switch (this.defaultMQPushConsumer.getMessageModel()) {
      case BROADCASTING:
        this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
        break;
      case CLUSTERING:
        this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());
        break;
      default:
        break;
    }
    this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);
  }
  this.offsetStore.load();

  if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {
    this.consumeOrderly = true;
    this.consumeMessageService =
      new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());
  } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {
    this.consumeOrderly = false;
    this.consumeMessageService =
      new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());
  }
  //启动ConsumeMessageService，执行具体的消费任务
  this.consumeMessageService.start();

  boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);
  if (!registerOK) {
    this.serviceState = ServiceState.CREATE_JUST;
    this.consumeMessageService.shutdown();
    throw new MQClientException("The consumer group[" + this.defaultMQPushConsumer.getConsumerGroup()
                                + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                                null);
  }

  mQClientFactory.start();
  log.info("the consumer [{}] start OK.", this.defaultMQPushConsumer.getConsumerGroup());
  this.serviceState = ServiceState.RUNNING;

  this.updateTopicSubscribeInfoWhenSubscriptionChanged();
  this.mQClientFactory.checkClientInBroker();
  //向broker发送心跳信息
  this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
  this.mQClientFactory.rebalanceImmediately();
}
```

#### 1.check各个配置项

#### 2.构建订阅主题信息

进入方法：

```java
private void copySubscription() throws MQClientException {
  //复制从DefaultMQProducer传入的订阅信息
  Map<String, String> sub = this.defaultMQPushConsumer.getSubscription();
  if (sub != null) {
    for (final Map.Entry<String, String> entry : sub.entrySet()) {
      final String topic = entry.getKey();
      final String subString = entry.getValue();
      SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                                                                          topic, subString);
      this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);
    }
  }

  if (null == this.messageListenerInner) {
    this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();
  }
	//switch消费模式
  switch (this.defaultMQPushConsumer.getMessageModel()) {
    //广播模式
    case BROADCASTING:
      break;
    //集群模式
    case CLUSTERING:
      //订阅一个消费组特定的重试主题，形如:%RETRY%消费组名称
      final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());
      SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),
                                                                          retryTopic, SubscriptionData.SUB_ALL);
      this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);
      break;
    default:
      break;
  }

}
```

### 3.创建MQClientInstance

## 消费消息



# 结语



(水平有限，最近在看rocketmq源码，记录学习过程，也希望对各位有点微小的帮助。如有错误，请指正~)

